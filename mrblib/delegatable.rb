# Error generated by +delegate+ when a method is called on +nil+ and +allow_nil+
# option is not used.
class DelegationError < NoMethodError
end

# https://raw.githubusercontent.com/rails/rails/a2bb266a7f546edfba8e82e75f1f01bb359f7bbd/activesupport/lib/active_support/core_ext/module/delegation.rb
module Delegatable
  RUBY_RESERVED_WORDS =
    %w(alias and BEGIN begin break case class def defined? do else elsif END
       end ensure false for if in module next nil not or redo rescue retry
       return self super then true undef unless until when while yield)

  # Swiped from activesupport/lib/active_support/core_ext/module/delegation.rb
  def delegate(*methods)
    options = methods.pop
    unless options.is_a?(Hash) && to = options[:to]
      raise ArgumentError, 'Delegation needs a target. Supply an options hash with a :to key as the last argument (e.g. delegate :hello, to: :greeter).'
    end

    prefix, allow_nil = options[:prefix], options[:allow_nil]

    if prefix == true && to =~ /^[^a-z_]/
      raise ArgumentError, 'Can only automatically set the delegation prefix when delegating to a method.'
    end

    method_prefix = if prefix
      "#{prefix == true ? to : prefix}_"
    else
      ''
    end

    # mruby doens't have caller, so lets make a thing...
    #file, line = caller.first.split(':', 2)
    file, line = "Delegatable<#{self}>", 1
    line = line.to_i

    to = to.to_s
    to = "self.#{to}" if RUBY_RESERVED_WORDS.include?(to)

    methods.each do |method|
      definition = '*args, &block'
      # The following generated method calls the target exactly once, storing
      # the returned value in a dummy variable.
      #
      # Reason is twofold: On one hand doing less calls is in general better.
      # On the other hand it could be that the target has side-effects,
      # whereas conceptually, from the user point of view, the delegator should
      # be doing one call.

      # HACK:
      #   its that horrible moment where you have to use a define_method inside
      #   an instance_eval in order to emulate class/module eval.

      if allow_nil
        method_def = [
          "define_method \"#{method_prefix}#{method}\" |#{definition}|",
          "  _ = #{to}",
          "  if !_.nil? || nil.respond_to?(:#{method})",
          "    _.#{method}(#{definition})",
          "  end",
          "end"
        ].join ";\n"
      else
        exception = %(raise DelegationError, "#{self}##{method_prefix}#{method} delegated to #{to}.#{method}, but #{to} is nil: \#{self.inspect}")

        method_def = [
          "define_method \"#{method_prefix}#{method}\" do |#{definition}|",
          "  begin",
          "    _ = #{to}",
          "    _.#{method}(#{definition})",
          "  rescue NoMethodError => e",
          "    if _.nil? && e.name == :#{method}",
          "      #{exception}",
          "    else",
          "      raise",
          "    end",
          "  end",
          "end"
        ].join ";\n"
      end

      #singleton_class.instance_eval(method_def, file, line)
      instance_eval(method_def, file, line)
    end
  end
end
